## 2.3 设计算法

&emsp;我们可以从许多算法设计方法中进行选择。对于插入排序，我们使用的是***增量法（incremental approach）***：在排序子数组 $A[1..j-1]$ 后，将单个元素 $A[j]$ 插入子数组的适当位置，并以此迭代。

&emsp;在这节中，我们将研究另一种设计方法，即 ***“分治法（divide-and-conquer）”***，在第四章中我们会详细介绍。我们将会使用分治法来设计一个排序算法，该算法在最糟糕的情况下比插入排序的运行时间少很多。分治法算法的一个优点是，我们能用第四章的技巧很容易地算出其运行时间。

### 2.3.1 分治法

&emsp;很多使用广泛的算法在结构上都是***递归（recuisive）*** 的：为了解决一个给定的问题，算法一次或者多次递归地调用自己来解决非常相近的子问题。这些算法通常都使用分治法：将一个问题分解为几个与原问题相近但是尺寸更小的子问题，递归地解决这些子问题，然后将所有的解合并，生成原问题的解。

​	 ***分治范式（divide-and-conquer paradigm）***在递归的每一层都包含三个步骤: 

- ***分解（devide）***：将原问题分解为若干子问题，这些子问题是原问题的规模较小的实例。
- ***解决（conquer）***：通过递归求解各子问题。若子问题的规模足够小，则以一种直接的方式求解。
- ***合并（combine）***：将子问题的解合成为原问题的解。

&emsp; ***合并排序（merge sort）***算法严格遵循分治范式。直观上，它的操作如下:

- 分解：将需要进行排序的 $n$ 个元素的序列分解为两个元素个数为 $n/2$ 的子序列。
- 解决：递归地使用合并排序来对这两个子序列进行排序。
- 合并：合并两个已排序的子序列来生成最终的已排序结果。