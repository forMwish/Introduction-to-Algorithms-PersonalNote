## 2.3 设计算法

&emsp;我们可以从许多算法设计方法中进行选择。对于插入排序，我们使用的是***增量法（incremental approach）***：在排序子数组 $A[1..j-1]$ 后，将单个元素 $A[j]$ 插入子数组的适当位置，并以此迭代。

&emsp;在这节中，我们将研究另一种设计方法，即 ***“分治法（divide-and-conquer）”***，在第四章中我们会详细介绍。我们将会使用分治法来设计一个排序算法，该算法在最糟糕的情况下比插入排序的运行时间少很多。分治法算法的一个优点是，我们能用第四章的技巧很容易地算出其运行时间。

### 2.3.1 分治法

&emsp;很多使用广泛的算法在结构上都是***递归（recuisive）*** 的：为了解决一个给定的问题，算法一次或者多次递归地调用自己来解决非常相近的子问题。这些算法通常都使用分治法：将一个问题分解为几个与原问题相近但是尺寸更小的子问题，递归地解决这些子问题，然后将所有的解合并，生成原问题的解。

​	 ***分治范式（divide-and-conquer paradigm）***在递归的每一层都包含三个步骤: 

- ***分解（divide）***：将原问题分解为若干子问题，这些子问题是原问题的规模较小的实例。
- ***解决（conquer）***：通过递归求解各子问题。若子问题的规模足够小，则以一种直接的方式求解。
- ***合并（combine）***：将子问题的解合成为原问题的解。

&emsp; ***合并排序（merge sort）***算法严格遵循分治范式。直观上，它的操作如下:

- 分解：将需要进行排序的 $n$ 个元素的序列分解为两个元素个数为 $n/2$ 的子序列。
- 解决：递归地使用合并排序来对这两个子序列进行排序。
- 合并：合并两个已排序的子序列来生成最终的已排序结果。

&emsp;当递归 ***“触底（bottoms out）”*** ，即需要排序的序列长度为1时，由于长度为1的序列“已经”被排序，所以不用再进行递归操作。

&emsp;合并排序算法的关键操作在于在 ***“合并（combine）”*** 步骤的时候合并两个已经排序的序列。我们通过调用一个名为 ***MERGE(A, p, q, r)*** 的辅助程序来进行合并操作，其中 ***A*** 是一个数组，***p, q, r*** 是数组的下标，满足 $p <= q < r$。该程序假设子数组 $A[p..q]$ 和 $A[q+1..r]$ 已经排序，然后将它们和并为一个单独的有序数组 $A[p..r]$。

&emsp;我们的合并程序需要花费的时间为 $Θ(n)$ ，其中 $n = r - p + 1$ 是需要合并的元素总数，它的原理如下。回到卡牌排序问题上来，假设我们有两堆正面朝上的牌，每一堆牌都已经被排序，且最上面的牌最小。我们希望合并这两堆牌，使最后的牌堆面朝下放在桌子上。我们的基础步骤如下：选择两个牌堆堆顶较小的牌，将其从牌堆上移开，并正面向下放在最终的牌堆上（输出）。重复这个步骤，直到两个输入牌堆中的一个剩余牌数为零，此时，直接将剩余的另一个输入牌堆面朝下放在输出牌堆之上。在计算上，由于我们只是比较两张最上面的牌，所以每个步骤所需的时间为常数，再加上最多步骤数量为 $n$，所以合并需要时间为 $Θ(n)$。

&emsp; 下面的伪代码实现了上面的思想，但是增加了一个额外的技巧，从而避免在每个基本步骤中检查每一堆是否为空。我们在每个堆的底部放置一个标记卡，其中包含一个特殊的值，用于简化代码。 在这里，我们使用 $∞$ 作为特殊值，当出现这个特殊值的牌的时候，表示排序结束。

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_pseudocode_2.3_1.png)

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_figure_2.3_1.png)

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_figure_2.3_2.png)

&emsp;使用循环不变性证明算法正确性：

- ***初始化（Initialization）***：在第一次循环迭代之前，$k=p$ ，因而子数组 $A[p..k-1]$ 为空，没有包含任何数组 $L$ 和数组 $R$ 的元素。
- ***维持（Maintenance）***：为了证明每次迭代维持循环不变性，我们先假设 $L[i] <= R[j]$。因此 $L[i]$ 是尚未被复制到数组 $A$ 的最小元素。由于 $A[p..k-1] $ 中包含 $k-p$ 个最小的元素，在伪代码第14行中，将$L[i]$ 拷贝到 $A[k]$ ，所以子数组 $A[p..k]$ 将包含 $k-p+1$ 个最小元素。
- ***结束（Termination）***：在结尾的时候，$k=r+1$ 。根据循环不变性，子数组 $A[p..k-1]$ 为 $A[p..r]$，其包含 $L[1..n_1+1]$ 和 $R[1..n_2+1]$ 的 $k-p=r-p+1$ 个有序最小元素。数组 $L$ 和 $R$ 一共包含 $n_1+n_2+3 = r-p+3$ 个元素，其中最大的两个元素（$∞$）被拷贝到数组 $A$。

&emsp;再来看看这个花费时间为 $Θ(n)，n=r-p+1$ 的合并过程，伪代码1-3行以及8-11行花费固定的时间，4-7行的 for 循环花费 $Θ(n_1+n_2)=Θ(n)$ 的时间，在第12-17行的循环中，共需要 $n$ 次迭代，每次都需要固定的时间。

&emsp; 我们现在可以将合并过程作为合并排序算法中的子例程使用。 $MERGE-SORT(A,p,r)$ 过程将元素在子数组 $A[p..r]$ 中进行排序。如果 $p>=r$ ，子数组有最大的元素，因此排序结束。此外，分解步骤只是简单地计算将   $A[p..r]$ 分解为两个子数组的索引 $q$ ：$A[p..q]$ 以及 $A[q+1..r]$ 各自包含 $ n/2$ 个元素。

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_pseudocode_2.3_2.png)

&emsp;为了对整个序列 A 进行排序，我们初始的时候调用 $MERGE-SORT(A,1,A.length)$ 。图2.4描述了当 $n$ 为 2 的幂的时候触底（bottom-up）的操作。