## 2.3 设计算法

&emsp;我们可以从许多算法设计方法中进行选择。对于插入排序，我们使用的是***增量法（incremental approach）***：在排序子数组 $A[1..j-1]$ 后，将单个元素 $A[j]$ 插入子数组的适当位置，并以此迭代。

&emsp;在这节中，我们将研究另一种设计方法，即 ***“分治法（divide-and-conquer）”***，在第四章中我们会详细介绍。我们将会使用分治法来设计一个排序算法，该算法在最糟糕的情况下比插入排序的运行时间少很多。分治法算法的一个优点是，我们能用第四章的技巧很容易地算出其运行时间。

### 2.3.1 分治法

&emsp;很多使用广泛的算法在结构上都是***递归（recursive）*** 的：为了解决一个给定的问题，算法一次或者多次递归地调用自己来解决非常相近的子问题。这些算法通常都使用分治法：将一个问题分解为几个与原问题相近但是尺寸更小的子问题，递归地解决这些子问题，然后将所有的解合并，生成原问题的解。

​	 ***分治范式（divide-and-conquer paradigm）***在递归的每一层都包含三个步骤: 

- ***分解（divide）***：将原问题分解为若干子问题，这些子问题是原问题的规模较小的实例。
- ***解决（conquer）***：通过递归求解各子问题。若子问题的规模足够小，则以一种直接的方式求解。
- ***合并（combine）***：将子问题的解合成为原问题的解。

&emsp; ***合并排序（merge sort）***算法严格遵循分治范式。直观上，它的操作如下:

- 分解：将需要进行排序的 $n$ 个元素的序列分解为两个元素个数为 $n/2$ 的子序列。
- 解决：递归地使用合并排序来对这两个子序列进行排序。
- 合并：合并两个已排序的子序列来生成最终的已排序结果。

&emsp;当递归 ***“触底（bottoms out）”*** ，即需要排序的序列长度为1时，由于长度为1的序列“已经”被排序，所以不用再进行递归操作。

&emsp;合并排序算法的关键操作在于在 ***“合并（combine）”*** 步骤的时候合并两个已经排序的序列。我们通过调用一个名为 ***MERGE(A, p, q, r)*** 的辅助程序来进行合并操作，其中 ***A*** 是一个数组，***p, q, r*** 是数组的下标，满足 $p <= q < r$。该程序假设子数组 $A[p..q]$ 和 $A[q+1..r]$ 已经排序，然后将它们和并为一个单独的有序数组 $A[p..r]$。

&emsp;我们的合并程序需要花费的时间为 $Θ(n)$ ，其中 $n = r - p + 1$ 是需要合并的元素总数，它的原理如下。回到卡牌排序问题上来，假设我们有两堆正面朝上的牌，每一堆牌都已经被排序，且最上面的牌最小。我们希望合并这两堆牌，使最后的牌堆面朝下放在桌子上。我们的基础步骤如下：选择两个牌堆堆顶较小的牌，将其从牌堆上移开，并正面向下放在最终的牌堆上（输出）。重复这个步骤，直到两个输入牌堆中的一个剩余牌数为零，此时，直接将剩余的另一个输入牌堆面朝下放在输出牌堆之上。在计算上，由于我们只是比较两张最上面的牌，所以每个步骤所需的时间为常数，再加上最多步骤数量为 $n$，所以合并需要时间为 $Θ(n)$。

&emsp; 下面的伪代码实现了上面的思想，但是增加了一个额外的技巧，从而避免在每个基本步骤中检查每一堆是否为空。我们在每个堆的底部放置一个标记卡，其中包含一个特殊的值，用于简化代码。 在这里，我们使用 $∞$ 作为特殊值，当出现这个特殊值的牌的时候，表示排序结束。

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_pseudocode_2.3_1.png)

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_figure_2.3_1.png)

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_figure_2.3_2.png)

&emsp;使用循环不变性证明算法正确性：

- ***初始化（Initialization）***：在第一次循环迭代之前，$k=p$ ，因而子数组 $A[p..k-1]$ 为空，没有包含任何数组 $L$ 和数组 $R$ 的元素。
- ***维持（Maintenance）***：为了证明每次迭代维持循环不变性，我们先假设 $L[i] <= R[j]$。因此 $L[i]$ 是尚未被复制到数组 $A$ 的最小元素。由于 $A[p..k-1] $ 中包含 $k-p$ 个最小的元素，在伪代码第14行中，将$L[i]$ 拷贝到 $A[k]$ ，所以子数组 $A[p..k]$ 将包含 $k-p+1$ 个最小元素。
- ***结束（Termination）***：在结尾的时候，$k=r+1$ 。根据循环不变性，子数组 $A[p..k-1]$ 为 $A[p..r]$，其包含 $L[1..n_1+1]$ 和 $R[1..n_2+1]$ 的 $k-p=r-p+1$ 个有序最小元素。数组 $L$ 和 $R$ 一共包含 $n_1+n_2+3 = r-p+3$ 个元素，其中最大的两个元素（$∞$）被拷贝到数组 $A$。

&emsp;再来看看这个花费时间为 $Θ(n)，n=r-p+1$ 的合并过程，伪代码1-3行以及8-11行花费固定的时间，4-7行的 for 循环花费 $Θ(n_1+n_2)=Θ(n)$ 的时间，在第12-17行的循环中，共需要 $n$ 次迭代，每次都需要固定的时间。

&emsp; 我们现在可以将合并过程作为合并排序算法中的子例程使用。 $MERGE-SORT(A,p,r)$ 过程将元素在子数组 $A[p..r]$ 中进行排序。如果 $p>=r$ ，子数组有最大的元素，因此排序结束。此外，分解步骤只是简单地计算将   $A[p..r]$ 分解为两个子数组的索引 $q$ ：$A[p..q]$ 以及 $A[q+1..r]$ 各自包含 $ n/2$ 个元素。

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_pseudocode_2.3_2.png)

&emsp;为了对整个序列 A 进行排序，我们初始的时候调用 $MERGE-SORT(A,1,A.length)$ 。图2.4描述了当 $n$ 为 2 的幂的时候触底（bottom-up）的操作。

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_figure_2.3_3.png)

### 2.3.2 分析分治算法

&emsp; 当一个算法包含对其自身的递归调用时，我们通常可以用递归方程或递归式来描述它的运行时间，递归式用较小输入的运行时间来描述一个规模为n的问题的总体运行时间。  然后，我们可以使用数学工具来解决递归问题，并为算法的性能提供界限。 

&emsp;分治算法运行时间的递归式由其三个基本范式得到。首先，假设 $T(n)$ 为问题规模为 $n$ 时所需的运行时间。如果问题的规模足够小，则称 $n<=c$ ，c 为一常数值，此时需要耗费常数时间，写作 $Θ(1)$。假设我们将问题切分为 $a$ 个子问题，每个子问题的规模是原来的 $1/b$ 。（在合并排序中，$a$ 和 $b$ 的值都是 2 ，但是我们将会接触很多 $a≠b$ 的分治算法。）子问题耗费的时间为 $T(n/b)$ ，因此一共需要耗费时间 $aT(n/b)$ 。如果分解需要耗费 $D(n)$ 的时间，合并需要耗费 $C(n)$ 的时间，可得递归式如下：

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_formula_2.3_1.png)

&emsp; 在第四章，我们将看到如何解决这种形式的常见递归。

#### 分析合并排序

&emsp;  尽管合并排序的伪代码在元素数量不均匀时可以正常工作，但是如果我们假设原始问题大小是2的幂，那么基于递归的分析就可以简化。 每个分解步骤都会产生两个规模为 $n/2$ 的子序列。在第四章中， 我们将看到这个假设并不影响递归解法的增长规律。 

&emsp;假定 $T(n)$ 表示规模为 $n$ 的最糟糕情况下合并排序所需要的运行时间。只有一个元素的合并排序只花费常量时间。当 $n>1$ 时，其运行时间计算如下：

- 分解（Divide）：分解步骤仅仅计算子数组的中间位置，所以花费常量时间。因此可得：$D(n)=Θ(1)$。
- 求解（Conquer）：我们递归地解决大小为 $n/2$ 的子问题，这需要 $2T(n/2)$ 的时间。
- 合并（Combine）：在此之前我们已经求得大小为 $n/2$ 的合并过程需要时间为 $C(n)=Θ(n)$。

&emsp;当我们将函数 $D(n)$ 和 $C(n)$ 相加，其结果为一个关于 $n$ 的线性函数（linear function），$Θ(n)$ 。将其与求解步骤中的 $2T(n/2)$ 相加，得到最糟糕情况下运行时间 $T(n)$ 的递归式如下：

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_formula_2.3_2.png)

&emsp;在第四章中，我们将会了解 “master theorem” ，并据此推算出 $T(n)$ 其实为 $Θ(nlgn)$ ，其中 $lgn$ 表示 $log_2n$。由于对数函数（logarithm function）比任何线性函数增长得都慢，因此在输入较大的情况下，合并排序远远比插入排序表现更佳。 

&emsp;我们不需要“master theorem”来直观理解 $T(n)=Θ(nlgn)$ 。让我们重写（2.1）的递归式：

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_formula_2.3_3.png)

&emsp; 其中常数c表示解决大小为1的问题所需的时间，包括其分解和合并每个数组元素所需的时间。

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_figure_2.3_4.png)

&emsp;图 2.5 展示了我们如何求解 2.2 的递归式。为了便于解释，我们假设 $n$ 为 2 的幂。图中(a)部分表示 $T(n)$ ，(b)部分表示其等价的树。 项 $cn$ 是根（递归顶层的开销），根的两个子树是两个较小的递归 $T(n/2)$ 。 最终展开成***递归树（recursion tree）***，如图(d)。

&emsp;最后，我们将树每层的耗时相加，可得每层耗时为 $cn$ 。通常，第 $i$ 层拥有 $2^i$ 个节点，每个节点的耗时都为 $c(n/2^i)$ ，因此第 $i$ 层总共耗时 $2^ic(n/2^i)=cn$ 。而底层有 $n$ 个节点，每个节点耗时 $c$ ，总共耗时 $cn$。

&emsp;图 2.5 中的递归树总共有 $lgn+1$ 层 。有种非正式的证明可以对此进行论证。当为 $n=1$ 这种最基础的情况时，$lg1=0$，该公式正确。

&emsp;为了计算 2.2 递归式的总共耗时，我们简单地将每层的耗时相加。递归树有 $lg(n)+1$ 层，每层耗时 $cn$，因而总共耗时为 $cn(lg(n)+1) = cnlg(n)+cn$ 。忽略低阶（low-order）项和常数 $c$ 可得结果 $Θ(n*lg(n))$ 。



#### 练习

***2.3-1*** 使用图 2.4 为模型，画图描述数组 $A=(3,41,52,26,38,57,9,49)$ 是如何进行合并排序的。

```

```



***2.3-2*** 重写 MERGE 程序，使之不需要使用无限符号，而是当 $L$ 或者 $R$ 数组的所有元素都拷贝到 $A$ 后，将剩余部分的元素全部拷贝回 $A$。

***2.3-3*** 用数学归纳法来证明当n是2的幂时，如下递归式的解为 $T(n)=n*lg(n)$。

 ![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_formula_2.3_4.png)

***2.3-4*** 我们可以使用递归过程来表示插入排序。为了排序数组 $A[1..n]$，我们递归地排序数组 $A[1..n-1]$ ，然后再将 $A[n]$ 插入到已经排序的数组 $A[1..n-1]$ 中。写出该递归版本插入排序的递归式表示其运行时间。

***2.3-5*** 