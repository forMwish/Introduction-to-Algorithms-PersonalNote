## 2.3 设计算法

&emsp;我们可以从许多算法设计方法中进行选择。对于插入排序，我们使用的是***增量法（incremental approach）***：在排序子数组 $A[1..j-1]$ 后，将单个元素 $A[j]$ 插入子数组的适当位置，并以此迭代。

&emsp;在这节中，我们将研究另一种设计方法，即 ***“分治法（divide-and-conquer）”***，在第四章中我们会详细介绍。我们将会使用分治法来设计一个排序算法，该算法在最糟糕的情况下比插入排序的运行时间少很多。分治法算法的一个优点是，我们能用第四章的技巧很容易地算出其运行时间。

### 2.3.1 分治法

&emsp;很多使用广泛的算法在结构上都是***递归（recuisive）*** 的：为了解决一个给定的问题，算法一次或者多次递归地调用自己来解决非常相近的子问题。这些算法通常都使用分治法：将一个问题分解为几个与原问题相近但是尺寸更小的子问题，递归地解决这些子问题，然后将所有的解合并，生成原问题的解。

​	 ***分治范式（divide-and-conquer paradigm）***在递归的每一层都包含三个步骤: 

- ***分解（devide）***：将原问题分解为若干子问题，这些子问题是原问题的规模较小的实例。
- ***解决（conquer）***：通过递归求解各子问题。若子问题的规模足够小，则以一种直接的方式求解。
- ***合并（combine）***：将子问题的解合成为原问题的解。

&emsp; ***合并排序（merge sort）***算法严格遵循分治范式。直观上，它的操作如下:

- 分解：将需要进行排序的 $n$ 个元素的序列分解为两个元素个数为 $n/2$ 的子序列。
- 解决：递归地使用合并排序来对这两个子序列进行排序。
- 合并：合并两个已排序的子序列来生成最终的已排序结果。

&emsp;当递归 ***“触底（bottoms out）”*** ，即需要排序的序列长度为1时，由于长度为1的序列“已经”被排序，所以不用再进行递归操作。

&emsp;合并排序算法的关键操作在于在 ***“合并（combine）”*** 步骤的时候合并两个已经排序的序列。我们通过调用一个名为 ***MERGE(A, p, q, r)*** 的辅助程序来进行合并操作，其中 ***A*** 是一个数组，***p, q, r*** 是数组的下标，满足 $p <= q < r$。该程序假设子数组 $A[p..q]$ 和 $A[q+1..r]$ 已经排序，然后将它们hi并为一个单独的有序数组 $A[p..r]$。

&emsp;我们的合并程序需要花费的时间为 $Θ(n)$ ，其中 $n = r - p + 1$ 是需要合并的元素总数，它的原理如下。

