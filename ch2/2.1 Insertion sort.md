##  2.1 插入排序

&emsp;在第一章中引入的插入排序可以解决 ***排序问题（sorting problem）***：

​	**Input**：n个数字的序列 $<a_1, a_2, ... , a_n>$.

​	**Output**：输入序列按照从小到大排序的序列 $<a'_1, a'_2, ... , a'_n>$。

&emsp;我们希望排序的数字也称为键。虽然从概念上讲我们是在对序列进行排序，但是输入是以包含n个元素的数组的形式出现的。在本书中，我们通常将算法描述为用伪代码编写的程序，这些伪代码在许多方面与C、c++、Java、Python或Pascal类似。如果您已经接触过这些语言中的任何一种，阅读我们的算法应该不会有什么困难。伪代码与“真实”代码的区别在于，在伪代码中，我们使用最清晰和简洁的表达方法来指定给定的算法。有时，最清晰的方法是英语，所以如果您遇到嵌入在“真实”代码中的英语短语或句子，不要感到惊讶。伪代码和真实代码的另一个区别是伪代码通常不涉及软件工程问题。为了更简洁地表达算法的本质，常常忽略数据抽象、模块性和错误处理等问题。

&emsp;我们从插入排序开始，插入排序是一种对少量元素进行排序的有效算法。插入排序的工作方式就像许多人对扑克牌进行排序一样。我们从空的左手开始，牌面朝下放在桌子上。然后我们每次从表中取出一张卡片，并将其插入到左手的正确位置。为了找到一张牌的正确位置，我们从右到左将它与现有的每张牌进行比较，如图2.1所示。在任何时候，左手中的牌都是经过排序的，而这些牌原本是桌子上那堆牌的最上面的。

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_figure_2.1.png)

&emsp;我们写出关于插入排序的伪代码，称之为 **INSERTION-SORT**，该程序对含有 $n$ 个元素的数组 $A[1...n]$ 进行排序。（在该代码中，我们用 $A.length$ 表示数组的元素个数。）该算法

对输入的数字进行排序：它对数组 $A$ 中所有数字进行重排，并且在任意时刻最多只有一个常量在数组外面。当 INSERTION-SORT 程序结束时，输入数组 $A$ 中的数字已经是重排后的输出。

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_figure_2.2.png)

> 图2.2 INSERTION-SORT 对数组 $A = <5, 2, 4, 6, 1, 3>$ 的操作。数组索引在矩形上方标出，数组相应位置中存储的值标注在矩形内。图$(a)-(e)$应对伪代码行$1-8$的 **for** 循环迭代。在每个迭代的第5行，黑色矩阵中的关键字 $A[j]$ 需要和其左边的灰色矩阵进行比较。灰色箭头显示在第6行伪代码中数组元素如何向右移动一个位置，黑色箭头显示在第8行伪代码中关键字如何移动。图 $(f)$ 是排序后的数组。

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_pseudocode_2.1.png)



#### 循环不变性和插入排序的正确性

&emsp;图 2.2 显示了该算法在输入为 $A = <5, 2, 4, 6, 1, 3>$ 时是如何工作的。索引 $j$ 表示需要被插入到手中卡片的“当前卡片”。在以 $j$ 为索引的每个 $for$ 循环迭代开始的时候，黑色矩形左边的数组 $A[1 ... j-1]$ 表示当前已经排序的数组，右边的数组 $A[j+1 ... n]$ 表示桌面上的牌堆。实际上，元素 $A[1 ... j-1]$ 就是之前牌堆中的 $1 ... j-1$ ，只不过现在已经被排序了。我们将 $A[1... j-1]$ 的这些性质正式表述为 ***循环不变性（loop invariant）***：

> 在伪代码 1-8 行，子数组 $A[1 ... j-1]$ 由原来的 $A[1 ... j-1]$ 经排序后组成。

&emsp;我们使用循环不变性来帮助我们理解为什么算法是正确的。我们必须展示循环不变性的三个性质：

- **初始化（Initialization）**：在第一次循环迭代之前，循环不变性是正确的；
- **保持（Maintenance）**：对某一次循环迭代而言，如果在它之前循环不变性是正确的，那么在下一次循环迭代之前，循环不变性保持其正确性；
- **终止（Termination）**：当循环终止，循环不变性给定一个特性以确认算法正确性。

&emsp;当前两个性质满足时，在每次循环迭代之前，循环不变性都是正确的。（当然，我们可以自由地使用除循环不变式本身之外的已建立的事实来证明循环不变式在每次迭代之前保持为真。）注意这里和数学归纳法的相似性：为了证明一个特性，你需要证明一个基本情况和一个归纳步骤。在这里，“初始化”对应基本情况，“维护”对应归纳步骤。

&emsp;第三个属性可能是最重要的一个，因为我们使用循环不变性来证明正确性。通常，我们使用循环不变性以及导致循环终止的条件。终止性质不同于我们通常使用的无限使用归纳步骤的数学归纳法；在这里，当循环终止时，我们停止“归纳”。

&emsp;让我们详细了解下插入排序的这些性质。

- **初始化**：首先，我们需要证明在第一次循环迭代之前，该算法具有循环不变性的特性。在第一次循环迭代之前，也就是 $j = 2$ 时，循环不变性所代表的子数组为 $A[1 ... j - 1 ]$ ，因此，仅包含单个元素 $A[ 1 ]$ 。也就是说，此时循环不变性是有序的，证明循环不变性的初始化特性。

- **保持**：接下来我们处理第二条特性：证明每次迭代都保持循环不变性。通常，**for** 循环的主体主要内容是移动 $A[j -1 ], A[j -2 ], A[j -3 ]$ ，直到为 $A[j]$ 找到一个正确的位置。然后将其插入。这样，子数组 $A[1 ... j]$ 所含的所有元素是有序的。因而也就证明了其循环不变性。

  &emsp;对第二个特性有一个更正式的处理方式，但是需要我们用 $5-7$ 行所示的 **while** 循环来描述和证明循环不变性。然而，关于这点，我们不喜欢陷入这种形式主义，所以我们依赖于我们的非正式分析来证明第二个特性适用于外部循环。

- **终止**：最后，我们解释一下在循环终止时算法是怎样的。当 $j>A.length = n$ 时， **for** 循环终止。由于每次循环迭代 $j$ 增加 1，当循环终止时，$j = n + 1$ ，此时子数组 $A[1...n]$ 包含原来数组中的所有元素，并且是有序的，因而该算法正确。

&emsp;以后，我们将用循环不变性来证明算法的正确性。



#### 伪代码约定

&emsp;我们将在伪代码中使用以下约定。

- 缩进表示块结构。（同 python）

- 循环结构 $while，for$ 以及条件结构 $repeat-until，if-else$ 都有和 $C，C++，Java，Python，Pascal$ 中对应结构相似的意义。

- “//”表示行注释。

- $i = j = e$ 等同于 $ j = e ; i = j $。

- 变量（如i、j和key）是给定过程的局部变量。在没有明确指示的情况下，我们不应该使用全局变量。

- 我们通过指定数组名后面方框内的数字，来访问任意的数组元素。

- 我们通常将复合数据组织为由 **属性（attributes）** 组成的 **对象（objects）**。

- 我们使用面向对象编程语言的语法来访问特定的属性：对象名.属性名。比如，将数组看作对象，其长度（length）属性表示数组中有多少个元素。我们用 $A.length$ 获取数组长度属性。

  我们使用表示一个数组或者对象的变量作为指向表示该数组或者对象的指针（对应python特性，以及C++浅拷贝）。对于对象 $x$ 中的所有属性 $f$ ，使 $y = x$ 可得 $y.f$ 等同于 $x.f$ 。此外，若有 $x.f = 3$ ，我们可以同时得到 $y.f = 3$ 。也就是说，在语句 $y = x$ 后，$x$ 和 $y$ 指向同一个对象。

  属性符号可以“**级联（cascade）**”。比如，假设属性 $f$ 本身是一个指向具有属性 $g$ 的某种类型对象的指针。那么 $x.f.g$ 等同于 $(x.f).g$ 。换句话说，如果已经指定 $y = x.f$ ，那么 $x.f.g$ 等同于 $y.g$ 。
  
  有时，指针根本不指向任何对象。在这种情况下，我们给它一个特殊的值NIL。
  
- 我们 ***按值*** 将参数传递给 ***程序（procedure）***：被调用的程序接收所有参数的拷贝，因而如果给参数赋值，该赋值造成的改动不会在调用程序中体现。对象被传递后，指向的数据代表拷贝后的对象，但是对象的属性并未拷贝。举个例子，假设 $x$ 是被调用程序的一个参数，那么在被调用程序中的赋值操作 $x = y$ 在调用程序中是不可见的。但是，赋值操作 $x.f = 3$ 是可见的。类似地，数组依靠指针进行传递，因此传递的是指针而不是整个数组，对单独的数组元素的改动对调用程序来说是可见的。

- **return（返回）** 声明将控制转移到调用程序。多数 **return** 声明同时也会返回一个值给调用程序。我们所使用的伪代码不同于大多数编程语言，它可以返回多个值。

- 布尔运算符 $"and" "or"$ 是 **短路（short circuiting）** 的。也就是说，在计算表达式 "x and y" 的时候，如果 x 计算为假，则不用再计算 y。 短路运算可以实现一些特殊的操作，比如" x ≠ NIL and x.f = y"，就不用担心 x = NIL 的时候会导致 x.f 出错。

- **error** 关键字表示由于被调用程序的条件不正确导致错误。调用程序负责处理这个错误，所以我们不用指定相应的操作。



#### 练习

***2.1-1*** 

以图2.2 为模型，画图说明 INSERTION-SORT 对数组 $A = [31,41,59,26,41,58]$ 的操作。



**2.1-2**

改写 INSERTION-SORT 程序，使其为非递增排序。

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_pseudocode_2.1.png)

```python
for j = 2 to A.length
	key = A[j]
    i = j - 1
    while i > 0 and A[i] < key
    	A[i+1] = A[i]
        i = i - 1
    A[i + 1] = key
```



**2.1-3**

思考这样一个搜索问题：

**Input**：一个有 n 个数字的数组 $A = <a_1, a_2, ... ,a_n>$ 以及一个值 $v$ 。

**Output**：满足 $v =  A[i]$ 的索引 $i$ ，如果没有，则返回 $NIL$ 。

写出搜索队列找出 $v$ 的 **线性查找（linear serch）** 伪代码。使用循环不变性证明算法正确性。确保你的循环不变性满足三条必要的性质。



**2.1-4**

将存放在两个 $n-element$ 的数组 A 和 B 的两个 $n-bit$ 二进制整数相加，并将二进制结果存放在一个 $(n+1)-element$ 数组 C 中。正式地描述问题并编写伪代码来将两个整数相加。























