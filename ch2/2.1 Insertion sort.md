##  2.1 插入排序

&emsp;在第一章中引入的插入排序可以解决 ***排序问题（sorting problem）***：

​	**Input**：n个数字的序列 $<a_1, a_2, ... , a_n>$.

​	**Output**：输入序列按照从小到大排序的序列 $<a'_1, a'_2, ... , a'_n>$。

&emsp;我们希望排序的数字也称为键。虽然从概念上讲我们是在对序列进行排序，但是输入是以包含n个元素的数组的形式出现的。在本书中，我们通常将算法描述为用伪代码编写的程序，这些伪代码在许多方面与C、c++、Java、Python或Pascal类似。如果您已经接触过这些语言中的任何一种，阅读我们的算法应该不会有什么困难。伪代码与“真实”代码的区别在于，在伪代码中，我们使用最清晰和简洁的表达方法来指定给定的算法。有时，最清晰的方法是英语，所以如果您遇到嵌入在“真实”代码中的英语短语或句子，不要感到惊讶。伪代码和真实代码的另一个区别是伪代码通常不涉及软件工程问题。为了更简洁地表达算法的本质，常常忽略数据抽象、模块性和错误处理等问题。

&emsp;我们从插入排序开始，插入排序是一种对少量元素进行排序的有效算法。插入排序的工作方式就像许多人对扑克牌进行排序一样。我们从空的左手开始，牌面朝下放在桌子上。然后我们每次从表中取出一张卡片，并将其插入到左手的正确位置。为了找到一张牌的正确位置，我们从右到左将它与现有的每张牌进行比较，如图2.1所示。在任何时候，左手中的牌都是经过排序的，而这些牌原本是桌子上那堆牌的最上面的。

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_figure_2.1.png)

&emsp;我们写出关于插入排序的伪代码，称之为 **INSERTION-SORT**，该程序对含有 $n$ 个元素的数组 $A[1...n]$ 进行排序。（在该代码中，我们用 $A.length$ 表示数组的元素个数。）该算法

对输入的数字进行排序：它对数组 $A$ 中所有数字进行重排，并且在任意时刻最多只有一个常量在数组外面。当 INSERTION-SORT 程序结束时，输入数组 $A$ 中的数字已经是重排后的输出。

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_figure_2.2.png)

> 图2.2 INSERTION-SORT 对数组 $A = <5, 2, 4, 6, 1, 3>$ 的操作。数组索引在矩形上方标出，数组相应位置中存储的值标注在矩形内。图$(a)-(e)$应对伪代码行$1-8$的 **for** 循环迭代。在每个迭代的第5行，黑色矩阵中的关键字 $A[j]$ 需要和其左边的灰色矩阵进行比较。灰色箭头显示在第6行伪代码中数组元素如何向右移动一个位置，黑色箭头显示在第8行伪代码中关键字如何移动。图 $(f)$ 是排序后的数组。

![](https://bin-note-picture.oss-ap-southeast-1.aliyuncs.com/Introduction to Algorithms/ch2_pseudocode_2.1.png)



#### 循环不变量和插入排序的正确性

&emsp;图 2.2 显示了该算法在输入为 $A = <5, 2, 4, 6, 1, 3>$ 时是如何工作的。索引 $j$ 表示需要被插入到手中卡片的“当前卡片”。在以 $j$ 为索引的每个 $for$ 循环迭代开始的时候，黑色矩形左边的数组 $A[1 ... j-1]$ 表示当前已经排序的数组，右边的数组 $A[j+1 ... n]$ 表示桌面上的牌堆。实际上，元素 $A[1 ... j-1]$ 就是之前牌堆中的 $1 ... j-1$ ，只不过现在已经被排序了。我们将 $A[1... j-1]$ 的这些性质正式表述为***循环不变量（loop invariant）***：

> 在伪代码 1-8 行，子数组 $A[1 ... j-1]$ 由原来的 $A[1 ... j-1]$ 经排序后组成。

&emsp;我们使用循环不变量来帮助我们理解为什么算法是正确的。我们必须展示循环不变量的三个方面:

