# 1 算法在计算中的角色

&emsp; 什么是算法？学习算法的价值何在？算法对其他在计算机上使用的技术的作用是什么？在本章中，我们将回答这些问题。

## 1.1 算法

&emsp; 通常，算法是一个将一些值作为输入，并且生成一些值作为输出的所有有用的计算过程 。因此，算法可以说是将输入转换为输出的一系列计算步骤。

&emsp; 我们也可以将算法视为解决特定计算问题的工具。问题的描述通常使用输入/输出的关系表示，算法描述了达到这种输入/输出关系的特定计算过程。

&emsp; 例如，我们可能需要将一串数字按 **非递减（nondecreasing）** 顺序排序。这个问题在实际中很常见，因此为引入许多标准设计技术和分析工具提供了一个很好的背景。这是我们通常定义的 **排序问题（sorting problem）**:

**输入**：n 个数字的序列 <$a_1$, $a_2$, ..., $a_n$>。

**输出**：重排输入排序为 <$a'_1$, $a'_2$, ..., $a'_n$>，使得 $a'_1$≤ $a'_2$≤ ... ≤ $a'_n$。

&emsp; 比如，给定序列<31, 41, 59, 26, 41, 58>作为排序算法的输入 ，则会返回序列<26, 31, 41, 41, 58, 59>作为输出。这样的输入序列被称为排序问题的一个**实例（instance）**。通常，**问题的实例（instance of a problem）**由输入==（包括问题描述中的任何约束条件）==。

&emsp; 因为许多问题都用排序作为中间步骤，所以它也是计算机科学中的基础操作。因此，我们有大量优秀的排序算法可供选择。哪种算法是给定应用下的最佳选择，取决于其他因素——排序项目的数量，项目已经排序的程度，项目的值上可能的限制，计算机体系结构以及所使用的存储设备种类：主存，硬盘乃至磁带。

&emsp; 如果对任意输入实例，都返回正确的输出，这样的算法被称为 **正确的** 。我们通常说一个正确的算法可以解决给定的计算问题。一个不正确的算法在某些输入实例下，可能不会停止，或者会返回错误的输出。与你可能的期望相反，如果我们能够控制它们的错误率，不正确的算法有时也是有用的。我们将在第31章学习寻找大素数的算法时看到一个具有可控错误率的算法示例。然而，通常我们只关心正确的算法。

&emsp; 一个算法可以通过文字，计算机程序，甚至硬件设计来定义。唯一的要求是，规范必须提供对所遵循计算过程的精确描述。<br><br>

#### 算法解决何种问题？

 &emsp; 排序并不是算法领域研究的唯一计算问题。（正如这么书的厚度。）算法的实际应用是普遍存在的，包括以下例子:

- 人类基因组计划在确定人类DNA中所有10万个基因、确定构成人类DNA的30亿个化学碱基对的序列、将这些信息存储在数据库中以及开发数据分析工具等目标方面取得了巨大进展。每一步都需要复杂的算法。虽然涉及到的各种问题的解决方案超出了本书的范围，但是许多解决这些生物问题的方法都使用了本书中几个章节的方法，从而使科学家能够在有效利用资源的同时完成任务。
- 互联网使世界各地的人们能够快速访问和检索大量的信息。在智能算法的帮助下，互联网上的网站能够管理和操作如次巨大的数据量。算法在这方面重要的应用包括：寻找数据传输的最佳路径（解决这类问题的技术在第24章），以及使用一个搜索引擎寻找特定信息存在的页面（相关技术在第11章和第32张）。
- 电子商务使商品和服务能够通过电子方式进行谈判和交换，它依赖于个人信息加密，如信用卡号码、密码和银行对账单。电子商务中使用的核心技术包括公钥密码学和数字签名(第31章将介绍)，这些技术基于数字算法和数字理论。
- 制造业和其他商业企业往往需要以最有效的方式分配稀缺资源。石油公司可能希望知道在哪里放置油井，以使其预期利润最大化。政治候选人可能想要决定在哪里花钱购买竞选广告，以便最大限度地增加赢得选举的机会。航空公司可能希望以尽可能便宜的方式分配机组人员，以确保每个航班都有保障，并符合政府有关机组人员调度的规定。Internet服务提供者可能希望确定在何处放置额外的资源，以便更有效地为其客户提供服务。所有这些都是可以用线性规划解决的问题的例子，我们将在第29章中学习。<br><br>

&emsp; 虽然这些示例的一些细节超出了本书的范围，但我们确实给出了应用于这些问题和问题领域的底层技术。我们还展示了如何解决许多具体问题，包括:

- 给定一个路线图，上面标出了每对相邻交叉口之间的距离，我们希望确定从一个交叉口到另一个交叉口的最短路线。即使我们不允许交叉的路线,可能的路线数量也是巨大的。我们如何选择所有可能的路线中最短的一条？在这里，我们将路线图(它本身就是实际道路的模型)建模为一个图(我们将在第VI部分和附录B中遇到)，并希望在图中找到从一个顶点到另一个顶点的最短路径。我们将在第24章中看到如何有效地解决这个问题。
- 给定两个有序符号序列，X 和 Y，寻找两者共有的最长序列。X和Y的共有序列的长度可以用来衡量这两个序列的相似性。例如，如果这两个序列是DNA链中的碱基对，那么如果它们有一个很长的公共子序列，我们可能会认为它们是相似的。如果X有m个对象，Y有n个对象，那么X和Y分别有 $2^m$ 和 $2^n$ 个可能的子序列。选择所有可能的X和Y子序列并将它们匹配起来可能要花费相当长的时间，除非m和n非常小。我们将在第15章中看到如何使用一种称为动态规划的通用技术来更有效地解决这个问题。
- 我们得到了一个机械设计的部件库，其中每个部件可能包含其他部件的实例，我们需要按顺序列出这些部件，以便每个部件出现在使用它的任何部件之前。如果设计包括n部分,那么可能有 n! 种可能的排列，n! 表示阶乘。因为阶乘函数的增长速度甚至比指数函数还快，所以我们无法生成每个可能的顺序，然后验证在这个顺序中，每个部分出现在使用它的部分之前(除非我们只有几个部分)。这个问题是拓扑排序的一个例子，我们将在第22章看到如何有效地解决这个问题。
- 平面上有n个点，我们希望找到这些点的凸包。凸包是包含点的最小凸多边形。直观地说，我们可以把每个点想象成一块木板上伸出来的钉子。凸包将由一个紧密的橡皮筋来表示，环绕所有的钉子。橡皮筋所绕的每个钉子都是凸包的一个顶点。(参见第1029页的图33.6)。点的 $2^n$ 个子集中的任意一个都可能是凸包的顶点。知道哪些点是凸包的顶点也是不够的，因为我们还需要知道它们出现的顺序。因此，凸包的顶点有很多选择。第33章给出了求凸包的两种较好的方法。<br><br>

&emsp; 这些列表远非详尽无遗（正如您可能再次从本书的分量中推测的那样），但它们展示了许多有趣算法问题的两个共同特征：

1. 他们有很多备选的解决方法，但是他们的绝大多数并不会解决你面对的问题。找出一个有用的、乃至最好的算法是一个非常大的挑战。
2. 它们有实际应用。在上面列出的问题中，最简单的例子是找到最短路径。运输公司，如卡车运输公司或铁路公司，寻找公路或铁路网络的最短路径和经济利益紧密相关，因为走较短的路径会导致较低的劳动力和燃料成本。以及，Internet上的路由节点可能需要找到通过网络的最短路径，以便快速路由消息。以及，一个想从纽约开车去波士顿的人可能想在对应网站上找到开车的方向，或者使用GPS。<br><br>

&emsp; 并不是每个算法解决的问题都有一组容易识别的候选解决方案。例如，假设我们有一组表示信号样本的数值，我们想计算这些样本的离散傅里叶变换。离散傅里叶变换将时域转化为频域，产生一组数值系数，从而确定采样信号中各频率的强度。离散傅里叶变换不仅是信号处理的核心，而且在数据压缩和大多项式与整数相乘方面也有应用。第30章给出了一个有效的算法，快速傅里叶变换(通常称为FFT)，并设计了一个硬件电路来计算FFT。<br><br>

#### 数据结构

&emsp;本书还包含几种数据结构。**数据结构（data structure）**是一种存储和组织数据方法，其目的是为了灵活访问和修改数据。没有一种数据结构能够很好地满足所有目的，因此了解其中几种数据结构的优点和局限性是很重要的。<br><br>

#### 技术

&emsp;虽然您可以将本书作为算法的“烹饪书”使用，但是有一天您可能会遇到一个问题，您无法轻易找到已出版的算法(例如，本书中的许多练习和问题)。这本书将教你算法设计和分析的技术，这样你就可以自己开发算法，得到正确的答案，并理解它们如何运作。不同章节涉及的算法解决不同方面的问题。有些章节处理特定的问题，如在第9章中找到中间值和顺序统计，在第23章中计算最小生成树，在第26章中确定网络中的最大流量。其他章节介绍了一些技术，如第4章中的分治、第15章中的动态规划和第17章中的平摊分析。<br><br>

#### 难题

&emsp;本书的大部分都是关于高效算法的。然而，有些问题并没有高效算法。第34章将会了解这些有趣问题中的一个——NP-complete。

&emsp;为什么 NP-complete 是有趣的？首先，虽然还没有发现一个 np-complete 问题的有效算法，但是还没有人证明一个 np-complete 问题的有效算法是不存在的。也就是说，没有人知道 NP-complete 问题是否存在一个高效算法。其次，np-complete 问题集具有一个显著的性质，如果其中任何一个问题存在有效算法，那么所有问题都存在有效算法。NP-complete问题之间的这种关系使得其解决方案变得更加诱人。最后，几个 np-complete 问题与我们所知道的有效算法的问题相似，但并不完全相同。计算机科学家们很感兴趣的是，对问题描述的一个小改动如何能对最著名算法的效率产生巨大的影响。<br>&emsp;你应该了解 NP-complete 问题，因为其中一些问题在实际应用中经常出现。如果您被要求为 NP-complete 问题生成一个高效算法，那么您很可能要花费大量的时间进行毫无结果的搜索。如果你能证明这个问题是 NP-complete ，你就可以不必把时间花在开发这样一个算法上面。<br>&emsp;作为一个具体的例子，考虑一个具有中心仓库的配送公司。每天，它在仓库装载每一辆运货卡车，并把货物送到几个地址。在每一天结束的时候，每辆卡车必须回到仓库，以便准备装载第二天的货物。为了减少成本，该公司希望选择一个配送站的顺序，使得每辆卡车的运送距离最短。这个问题就是著名的“旅行推销员问题”，它是 np-complete 的。它没有已知的高效算法。然而，在某些假设下，我们已知某种高效算法给出的总距离不超过可能的最小值太远。第35章讨论了这种“近似算法”。<br><br>

#### 并行性

&emsp;多年来，我们可以指望处理器时钟速度以稳定的速度增长。然而，基础物理阻碍了一直增长的时钟频率：由于能量密度的增长较时钟频率的增长是超线性的，因而当时钟频率超过一定限度，芯片就有融化的风险。为了继续提升单位时间内的运算量，芯片逐渐设计为**多核（cores）**架构。我们可以将这些多核计算机比作单芯片上具有多个有序的计算单元；也就是说，它们是一种“并行计算机”。为了发掘多核计算机的最佳性能，我们需要在设计算法的同时，考虑并行性。第27章提出了一种充分利用多核优点的“多线程”算法模型。该模型从理论的角度来看具有一定的优势，并为包括冠军象棋程序在内的多个成功的计算机程序奠定了基础。<br><br>

#### 练习

***1.1-1***

给出一个需要排序的实际例子或一个需要计算凸包的实际例子。

```
排序的例子：强迫症可能极其需要这种算法；
凸包的例子：地主圈地
```

