# 1 算法在计算中的角色

&emsp; 什么是算法？学习算法的价值何在？算法对其他在计算机上使用的技术的作用是什么？在本章中，我们将回答这些问题。

## 1.1 算法

&emsp; 通常，算法是一个将一些值作为输入，并且生成一些值作为输出的所有有用的计算过程 。因此，算法可以说是将输入转换为输出的一系列计算步骤。

&emsp; 我们也可以将算法视为解决特定计算问题的工具。问题的描述通常使用输入/输出的关系表示，算法描述了达到这种输入/输出关系的特定计算过程。

&emsp; 例如，我们可能需要将一串数字按 **非递减（nondecreasing）** 顺序排序。这个问题在实际中很常见，因此为引入许多标准设计技术和分析工具提供了一个很好的背景。这是我们通常定义的 **排序问题（sorting problem）**:

**输入**：n 个数字的序列 <$a_1$, $a_2$, ..., $a_n$>。

**输出**：重排输入排序为 <$a'_1$, $a'_2$, ..., $a'_n$>，使得 $a'_1$≤ $a'_2$≤ ... ≤ $a'_n$。

&emsp; 比如，给定序列<31, 41, 59, 26, 41, 58>作为排序算法的输入 ，则会返回序列<26, 31, 41, 41, 58, 59>作为输出。这样的输入序列被称为排序问题的一个**实例（instance）**。通常，**问题的实例（instance of a problem）**由输入==（包括问题描述中的任何约束条件）==。

&emsp; 因为许多问题都用排序作为中间步骤，所以它也是计算机科学中的基础操作。因此，我们有大量优秀的排序算法可供选择。哪种算法是给定应用下的最佳选择，取决于其他因素——排序项目的数量，项目已经排序的程度，项目的值上可能的限制，计算机体系结构以及所使用的存储设备种类：主存，硬盘乃至磁带。

&emsp; 如果对任意输入实例，都返回正确的输出，这样的算法被称为 **正确的** 。我们通常说一个正确的算法可以解决给定的计算问题。一个不正确的算法在某些输入实例下，可能不会停止，或者会返回错误的输出。与你可能的期望相反，如果我们能够控制它们的错误率，不正确的算法有时也是有用的。我们将在第31章学习寻找大素数的算法时看到一个具有可控错误率的算法示例。然而，通常我们只关心正确的算法。

&emsp; 一个算法可以通过文字，计算机程序，甚至硬件设计来定义。唯一的要求是，规范必须提供对所遵循计算过程的精确描述。<br><br>

#### 算法解决何种问题？

 &emsp; 排序并不是算法领域研究的唯一计算问题。（正如这么书的厚度。）算法的实际应用是普遍存在的，包括以下例子:

- 人类基因组计划在确定人类DNA中所有10万个基因、确定构成人类DNA的30亿个化学碱基对的序列、将这些信息存储在数据库中以及开发数据分析工具等目标方面取得了巨大进展。每一步都需要复杂的算法。虽然涉及到的各种问题的解决方案超出了本书的范围，但是许多解决这些生物问题的方法都使用了本书中几个章节的方法，从而使科学家能够在有效利用资源的同时完成任务。
- 互联网使世界各地的人们能够快速访问和检索大量的信息。在智能算法的帮助下，互联网上的网站能够管理和操作如次巨大的数据量。算法在这方面重要的应用包括：寻找数据传输的最佳路径（解决这类问题的技术在第24章），以及使用一个搜索引擎寻找特定信息存在的页面（相关技术在第11章和第32张）。
- 电子商务使商品和服务能够通过电子方式进行谈判和交换，它依赖于个人信息加密，如信用卡号码、密码和银行对账单。电子商务中使用的核心技术包括公钥密码学和数字签名(第31章将介绍)，这些技术基于数字算法和数字理论。
- 制造业和其他商业企业往往需要以最有效的方式分配稀缺资源。石油公司可能希望知道在哪里放置油井，以使其预期利润最大化。政治候选人可能想要决定在哪里花钱购买竞选广告，以便最大限度地增加赢得选举的机会。航空公司可能希望以尽可能便宜的方式分配机组人员，以确保每个航班都有保障，并符合政府有关机组人员调度的规定。Internet服务提供者可能希望确定在何处放置额外的资源，以便更有效地为其客户提供服务。所有这些都是可以用线性规划解决的问题的例子，我们将在第29章中学习。<br><br>

&emsp; 虽然这些示例的一些细节超出了本书的范围，但我们确实给出了应用于这些问题和问题领域的底层技术。我们还展示了如何解决许多具体问题，包括:

- 给定一个路线图，上面标出了每对相邻交叉口之间的距离，我们希望确定从一个交叉口到另一个交叉口的最短路线。即使我们不允许交叉的路线,可能的路线数量也是巨大的。我们如何选择所有可能的路线中最短的一条？在这里，我们将路线图(它本身就是实际道路的模型)建模为一个图(我们将在第VI部分和附录B中遇到)，并希望在图中找到从一个顶点到另一个顶点的最短路径。我们将在第24章中看到如何有效地解决这个问题。
- 给定两个有序符号序列，X 和 Y，寻找两者共有的最长序列。X和Y的共有序列的长度可以用来衡量这两个序列的相似性。例如，如果这两个序列是DNA链中的碱基对，那么如果它们有一个很长的公共子序列，我们可能会认为它们是相似的。如果X有m个对象，Y有n个对象，那么X和Y分别有 $2^m$ 和 $2^n$ 个可能的子序列。选择所有可能的X和Y子序列并将它们匹配起来可能要花费相当长的时间，除非m和n非常小。我们将在第15章中看到如何使用一种称为动态规划的通用技术来更有效地解决这个问题。
- 我们得到了一个机械设计的部件库，其中每个部件可能包含其他部件的实例，我们需要按顺序列出这些部件，以便每个部件出现在使用它的任何部件之前。如果设计包括n部分,那么可能有 n! 种可能的排列，n! 表示阶乘。因为阶乘函数的增长速度甚至比指数函数还快，所以我们无法生成每个可能的顺序，然后验证在这个顺序中，每个部分出现在使用它的部分之前(除非我们只有几个部分)。这个问题是拓扑排序的一个例子，我们将在第22章看到如何有效地解决这个问题。
- 平面上有n个点，我们希望找到这些点的凸包。凸包是包含点的最小凸多边形。直观地说，我们可以把每个点想象成一块木板上伸出来的钉子。凸包将由一个紧密的橡皮筋来表示，环绕所有的钉子。橡皮筋所绕的每个钉子都是凸包的一个顶点。(参见第1029页的图33.6)。点的 $2^n$ 个子集中的任意一个都可能是凸包的顶点。知道哪些点是凸包的顶点也是不够的，因为我们还需要知道它们出现的顺序。因此，凸包的顶点有很多选择。第33章给出了求凸包的两种较好的方法。<br><br>&emsp; 这些列表远非详尽无遗（正如您可能再次从本书的分量中推测的那样），但它们展示了许多有趣算法问题的两个共同特征：