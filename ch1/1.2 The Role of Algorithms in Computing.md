### 1.2 算法——一种技术

&emsp;假如计算机无穷快，并且计算内存完全免费，你还有其它理由来学习算法吗？如果你希望用自己的解决方法来得到正确答案，那么答案是肯定的。

&emsp;如果计算机无限快，任何可以正确解决问题的方法都是可以使用的。你或许会运用大量优良的软件工程实践来实现你的算法，但是你通常会使用最简单的方法来实现。

&emsp;当然，计算机很快，但是并不是无限快的。另外，内存或许便宜，但也不是免费的。计算时间和内存空间都是有限资源。你应该聪明地使用这些资源，而在时间或者空间上的高效算法会帮助你这么做。<br><br>

#### 效率

&emsp;为解决同一问题而设计的不同算法，其效率往往相差很大。这些差异可能比硬件和软件造成的差异更为显著。

&emsp;在第二章，我们将会看到排序算法这方面的两个例子。第一个称为 **插入排序（insertion sort）**，对 $n$ 个对象排序，其花费的时间大致为 $c_1n^2$ ，其中 $c_1$ 是一个与 $n$ 无关的常量。也就是说，它花费的时间大致与 $n^2$ 成正比。第二个称为 **归并排序（merge sort）**，对 $n$ 个对象排序，其花费的时间大致为 $c_2n \lg n$ ，这里 $\lg n$ 表示 $\log_2 n$ ，$c_2$ 是无关 $n$ 的常量 。插入排序的常量通常小于归并排序，即 $c_1 < c_2$。我们将看到，相对于输入大小 $n$ ，常数因子对运行时间的影响要小得多。插入排序的运行时间写作：$c_1n*n$ ，对应归并排序写作：$c_2n* \lg n$。显而易见，两者的差异之处存在 $n > \lg n$。虽然对于对象数量较小的输入，插入排序通常比归并排序更快，但是一旦输入对象数量 $n$ 足够大，归并排序的 $\lg n$ 相较于 $n$ 的优势就会超过常量因素差异导致的劣势。不管 $c_1$ 比 $c_2$ 小多少，总有这样一个点——当 $n$ 超过这个点时，归并排序就会比插入排序更快。<br>&emsp;举一个具体的例子，让我们选择一个性能更强的计算机A运行插入排序，作为对比，选择一个更慢的计算机B运行归并排序。它们将排序一个1000万个数字。（虽然1000万看起来似乎很多，如果每个数字都是8bit，那么输入总共80Mb，这样即使便宜的笔记本都能轻松容纳。）假设计算机A每秒运算量为100亿（这在创作这本书的时候比任何单顺序计算机都快），计算机B每秒运算量为1000万，也就是说，计算机A的速度是计算机B的1000倍。为了使这种差别更加显著，假设世界上最聪明的程序员用机器语言为计算机A编写插入排序代码，而生成的代码需要 $2n^2$ 条指令来对 $n$ 个数字排序。进一步假设，仅仅一个普通的程序员实现了归并排序，使用高级语言和低效的编译器，生成的代码使用 $50n \lg n$ 条指令。排列1000万个数字，计算机A需要
$$
\frac{2*(10^7)^2 条指令}{10^{10}条指令每秒} = 20,000 seconds （超过5.5小时）
$$
而计算机B需要
$$
\frac{50 \cdot 10^7 \lg 10^7 指令}{10^7指令每秒} \approx 1163 秒（不到 20 分钟）
$$
&emsp;通过使用一个运行时间增长更慢的算法，即使使用一个糟糕的编译器，计算机B的运行速度也比计算机A快17倍以上！当我们对1亿个数字进行排序时，合并排序的优势更加明显：插入排序需要超过23天，合并排序需要不到4小时。一般来说，随着问题规模的增加，归并排序的相对优势也会增加。<br><br>

#### 算法和其它技术

&emsp;上面的例子表明，我们应该把算法，就像计算机硬件一样，当作一种 **技术（technology）** 来考虑。整个系统的性能取决于选择高效的算法和快速的硬件。正如其他计算机技术正在取得迅速进步一样，算法也在取得进步。

&emsp;你或许会疑问，是否算法真的像其它先进的技术一样对现代计算机非常重要，比如：

- 先进的计算机架构和制造技术；
- 易于使用、直观、图形化的用户界面（GUIs）;
- 面向对象的系统；
- 集成 Web 技术；
- 有线以及无线高速网络。

&emsp;答案是肯定的。虽然有些应用程序在应用程序级别上不显式地需要算法内容（例如一些简单的基于web的应用程序），但是很多应用程序都需要。例如，考虑一个基于web的服务，它决定如何从一个位置旅行到另一个位置。它的实现将依赖于快速硬件、图形用户界面、广域网络，也可能依赖于面向对象。但是，对于某些操作，它还需要算法，例如查找路由（可能使用最短路径算法）、绘制映射和内插地址。

